<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Image Compressor</title>
	<style>
		:root {
			--bg: #ffffff;
			--text: #222;
			--muted: #666;
			--border: #e9e9e9;
			--accent: #222;
			--hover: #f8f8f8;
			--shadow: 0 2px 8px rgba(0,0,0,0.1);
			--shadow-hover: 0 4px 16px rgba(0,0,0,0.15);
			--primary: #F89344;
			--secondary: #FF642F;
		}
		body { 
			font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, Arial, sans-serif; 
			margin: 0;
			color: var(--text);
			background: var(--bg);
			line-height: 1.6;
		}
		.container { max-width: 1100px; margin: 0 auto; padding: 24px; }
		.ad-space-left { position: fixed; left: 0; top: 0; width: 160px; height: 100vh; background: #f8f8f8; border-right: 1px solid var(--border); z-index: 5; }
		.ad-space-right { position: fixed; right: 0; top: 0; width: 160px; height: 100vh; background: #f8f8f8; border-left: 1px solid var(--border); z-index: 5; }
		.main-content { margin-left: 160px; margin-right: 160px; }
		@media (max-width: 1200px) {
			.ad-space-left, .ad-space-right { display: none; }
			.main-content { margin-left: 0; margin-right: 0; }
		}
		h1 { font-size: 28px; margin: 0 0 24px; font-weight: 600; }
		
		/* Drag and Drop Zone */
		.drop-zone {
			border: 3px dashed var(--border);
			border-radius: 16px;
			padding: 60px 20px;
			text-align: center;
			background: var(--hover);
			transition: all 0.3s ease;
			cursor: pointer;
			margin-bottom: 24px;
			position: relative;
		}
		.drop-zone.dragover {
			border-color: var(--primary);
			background: rgba(248, 147, 68, 0.05);
			transform: scale(1.02);
		}
		.drop-zone .icon {
			font-size: 48px;
			margin-bottom: 16px;
			opacity: 0.6;
		}
		.drop-zone .text {
			font-size: 18px;
			font-weight: 500;
			margin-bottom: 8px;
			color: var(--text);
		}
		.drop-zone .subtext {
			font-size: 14px;
			color: var(--muted);
		}
		.drop-zone input[type="file"] {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			opacity: 0;
			cursor: pointer;
		}
		
		.controls { 
			display: grid; 
			grid-template-columns: 1fr 1fr 1fr 1fr; 
			gap: 16px; 
			margin: 24px 0; 
			align-items: end; 
		}
		label { 
			font-size: 14px; 
			color: var(--text); 
			font-weight: 500;
			margin-bottom: 8px;
			display: block;
		}
		input[type="number"], select { 
			width: 100%; 
			padding: 12px 16px; 
			border: 2px solid var(--border); 
			outline: none; 
			background: var(--bg); 
			border-radius: 8px;
			font-size: 14px;
			transition: all 0.2s ease;
		}
		input[type="number"]:focus, select:focus {
			border-color: var(--primary);
			box-shadow: 0 0 0 3px rgba(248, 147, 68, 0.1);
		}
		button { 
			appearance: none; 
			border: none; 
			background: var(--accent); 
			color: #fff; 
			padding: 14px 24px; 
			cursor: pointer; 
			border-radius: 8px;
			font-size: 14px;
			font-weight: 500;
			transition: all 0.2s ease;
		}
		button:hover:not(:disabled) {
			transform: translateY(-1px);
			box-shadow: var(--shadow);
		}
		button:disabled { 
			background: #999; 
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}
		.note { font-size: 14px; color: var(--muted); }
		
		progress { 
			width: 100%; 
			height: 8px; 
			border-radius: 4px;
			background: var(--hover);
		}
		progress::-webkit-progress-bar {
			background: var(--hover);
			border-radius: 4px;
		}
		progress::-webkit-progress-value {
			background: linear-gradient(90deg, var(--primary), var(--secondary));
			border-radius: 4px;
		}
		
		#errorBox { 
			margin-top: 16px; 
			padding: 16px; 
			border: 1px solid #f1b0b7; 
			background: #fdecef; 
			color: #75000f; 
			font-size: 14px; 
			white-space: pre-wrap; 
			display: none; 
			border-radius: 8px;
		}
		
		/* Universal nav */
		.navbar { 
			position: sticky; 
			top: 0; 
			background: var(--bg); 
			z-index: 10; 
			border-bottom: 1px solid var(--border); 
			padding: 16px 0; 
			margin-bottom: 24px; 
		}
		.nav { 
			display: flex; 
			align-items: center; 
			gap: 16px; 
		}
		.nav .brand { 
			font-weight: 600; 
			font-size: 18px;
		}
		.nav a { 
			color: var(--text); 
			text-decoration: none; 
			border: 1px solid var(--border); 
			padding: 8px 16px; 
			border-radius: 6px;
			transition: all 0.2s ease;
		}
		.nav a:hover {
			background: var(--hover);
			border-color: var(--primary);
		}
		.dropdown { 
			position: relative; 
			width: 320px; 
		}
		.dropdown input { 
			width: 100%; 
			padding: 10px 12px; 
			border: 1px solid var(--border); 
			outline: none; 
			border-radius: 6px; 
		}
		.dropdown .menu { 
			position: absolute; 
			left: 0; 
			right: 0; 
			background: var(--bg); 
			border: 1px solid var(--border); 
			border-top: none; 
			max-height: 280px; 
			overflow: auto; 
			display: none; 
			border-radius: 0 0 6px 6px;
			box-shadow: var(--shadow);
		}
		.dropdown.open .menu { 
			display: block; 
		}
		.dropdown .item { 
			padding: 10px 12px; 
			cursor: pointer; 
			border-top: 1px solid var(--border); 
			transition: background 0.2s ease;
		}
		.dropdown .item:hover { 
			background: var(--hover); 
		}
		
		@media (max-width: 768px) {
			.container { padding: 16px; }
			.controls { grid-template-columns: 1fr 1fr; }
		}
	</style>
</head>
<body>
	<div class="ad-space-left"></div>
	<div class="ad-space-right"></div>
	<div class="main-content">
		<div class="container">
		<div class="navbar">
			<div class="nav">
				<a href="index.html" class="brand">Infinite Tool</a>
				<div class="spacer"></div>
				<a href="index.html" title="Back to Home">‚Üê Back to Home</a>
			</div>
		</div>

		<h1>üóúÔ∏è Image Compressor</h1>
		
		<div class="drop-zone" id="dropZone">
			<div class="icon">üìÅ</div>
			<div class="text">Drop images here or click to browse</div>
			<div class="subtext">Supports PNG, JPG, GIF, SVG files</div>
			<input id="fileInput" type="file" accept="image/*,image/svg+xml" multiple>
		</div>
		
		<div class="controls">
			<div>
				<label for="maxW">Max width (px)</label>
				<input id="maxW" type="number" min="1" value="1920">
			</div>
			<div>
				<label for="maxH">Max height (px)</label>
				<input id="maxH" type="number" min="1" value="1080">
			</div>
			<div>
				<label for="quality">Quality (0.1-1)</label>
				<input id="quality" type="number" min="0.1" max="1" step="0.1" value="0.8">
			</div>
			<div>
				<label for="format">Format</label>
				<select id="format">
					<option value="image/jpeg">JPEG</option>
					<option value="image/webp">WEBP</option>
					<option value="image/png">PNG (no quality)</option>
				</select>
			</div>
		</div>
		
		<div class="row" style="gap:16px; align-items:center; margin-bottom: 24px;">
			<button id="compressBtn" disabled>üóúÔ∏è Compress</button>
			<button id="downloadZipBtn" disabled>üíæ Download ZIP</button>
			<span class="note" id="hint">Select images to compress.</span>
		</div>
		
		<div style="margin-top:16px;">
			<progress id="progress" value="0" max="1" style="display:none;"></progress>
		</div>
		
		<div id="errorBox"></div>
	</div>

	<script>

	</script>

	<script>
		const fileInput = document.getElementById('fileInput');
		const dropZone = document.getElementById('dropZone');
		const maxW = document.getElementById('maxW');
		const maxH = document.getElementById('maxH');
		const quality = document.getElementById('quality');
		const formatSel = document.getElementById('format');
		const compressBtn = document.getElementById('compressBtn');
		const downloadZipBtn = document.getElementById('downloadZipBtn');
		const progressEl = document.getElementById('progress');
		const hintEl = document.getElementById('hint');
		const errorBox = document.getElementById('errorBox');

		let jsZipBlobUrl = null; let zipBlobUrl = null; const createdObjectUrls = new Set();

		function logError(message, detail) { const lines = []; if (message) lines.push(message); if (detail) lines.push(String(detail)); errorBox.textContent = lines.join('\n'); errorBox.style.display = lines.length ? 'block' : 'none'; }
		
		// Drag and Drop functionality
		dropZone.addEventListener('dragover', (e) => {
			e.preventDefault();
			dropZone.classList.add('dragover');
		});
		
		dropZone.addEventListener('dragleave', (e) => {
			e.preventDefault();
			dropZone.classList.remove('dragover');
		});
		
		dropZone.addEventListener('drop', (e) => {
			e.preventDefault();
			dropZone.classList.remove('dragover');
			const droppedFiles = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
			handleFiles(droppedFiles);
		});
		
		dropZone.addEventListener('click', (e) => {
			// Only trigger file input if clicking on the drop zone itself, not on the input
			if (e.target === dropZone || e.target.closest('.icon') || e.target.closest('.text') || e.target.closest('.subtext')) {
				fileInput.click();
			}
		});

		function handleFiles(files) {
			if (zipBlobUrl) { URL.revokeObjectURL(zipBlobUrl); zipBlobUrl = null; }
			downloadZipBtn.disabled = true;
			compressBtn.disabled = files.length === 0;
			hintEl.textContent = files.length ? `${files.length} image(s) ready.` : 'Select images to compress.';
		}

		fileInput.addEventListener('change', () => { 
			handleFiles(Array.from(fileInput.files || []).filter(f => f.type.startsWith('image/')));
		});
		// Paste support: Ctrl/Cmd+V images
		window.addEventListener('paste', (e) => {
			const items = e.clipboardData && e.clipboardData.items ? Array.from(e.clipboardData.items) : [];
			const files = items.map(it => it.getAsFile && it.getAsFile()).filter(f => f && f.type && f.type.startsWith('image/'));
			if (files.length) { e.preventDefault(); handleFiles(files); }
		});
		
		function parseSvgSize(svgText) { try { const doc = new DOMParser().parseFromString(svgText, 'image/svg+xml'); const svg = doc.documentElement; let widthAttr = svg.getAttribute('width'); let heightAttr = svg.getAttribute('height'); let width = 0, height = 0; const parseLen = (v) => { if (!v) return 0; const m = String(v).trim().match(/([\d.]+)/); return m ? Math.max(0, Math.round(parseFloat(m[1]))) : 0; }; width = parseLen(widthAttr); height = parseLen(heightAttr); if ((!width || !height) && svg.hasAttribute('viewBox')) { const vb = svg.getAttribute('viewBox').trim().split(/[\s,]+/).map(Number); if (vb.length === 4 && vb[2] > 0 && vb[3] > 0) { width = width || Math.round(vb[2]); height = height || Math.round(vb[3]); } } if (!width || !height) { width = width || 512; height = height || 512; } svg.setAttribute('width', String(width)); svg.setAttribute('height', String(height)); return { width, height, serialized: new XMLSerializer().serializeToString(svg) }; } catch (e) { return { width: 512, height: 512, serialized: svgText }; } }
		function loadImageFromFile(file) { return new Promise((resolve, reject) => { if (file.type === 'image/svg+xml') { const reader = new FileReader(); reader.onerror = () => reject(new Error(`Failed to read SVG: ${file.name}`)); reader.onload = e => { const { serialized } = parseSvgSize(String(e.target.result)); const blob = new Blob([serialized], { type: 'image/svg+xml' }); const url = URL.createObjectURL(blob); createdObjectUrls.add(url); const img = new Image(); img.onload = () => resolve(img); img.onerror = () => { URL.revokeObjectURL(url); createdObjectUrls.delete(url); reject(new Error(`Failed to load SVG image: ${file.name}`)); }; img.src = url; }; reader.readAsText(file); return; } const reader = new FileReader(); reader.onerror = () => reject(new Error(`Failed to read file: ${file.name}`)); reader.onload = e => { const img = new Image(); img.onload = () => resolve(img); img.onerror = () => reject(new Error(`Failed to load image: ${file.name}`)); img.src = e.target.result; }; reader.readAsDataURL(file); }); }
		function scaleToFit(img, maxWidth, maxHeight) { const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1); return { w: Math.round(img.width * scale), h: Math.round(img.height * scale) }; }
		async function ensureJsZip() { if (window.JSZip) return; const src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; const res = await fetch(src, { cache: 'force-cache' }); if (!res.ok) throw new Error('Failed to fetch JSZip: ' + res.status); const text = await res.text(); jsZipBlobUrl = URL.createObjectURL(new Blob([text], { type: 'application/javascript' })); await new Promise((resolve, reject) => { const s = document.createElement('script'); s.src = jsZipBlobUrl; s.onload = resolve; s.onerror = () => reject(new Error('Script load error for JSZip')); document.head.appendChild(s); }); if (!window.JSZip) throw new Error('JSZip not available after loading'); }

		compressBtn.addEventListener('click', async () => { 
			const files = Array.from(fileInput.files || []).filter(f => f.type.startsWith('image/')); 
			if (files.length === 0) return; 
			compressBtn.disabled = true; 
			downloadZipBtn.disabled = true; 
			progressEl.style.display = 'block'; 
			progressEl.value = 0; 
			progressEl.max = files.length; 
			logError(''); 
			try { 
				await ensureJsZip(); 
				const images = await Promise.all(files.map(loadImageFromFile)); 
				const zip = new JSZip(); 
				for (let i = 0; i < images.length; i++) { 
					const img = images[i]; 
					const target = scaleToFit(img, Math.max(1, parseInt(maxW.value || '1', 10)), Math.max(1, parseInt(maxH.value || '1', 10))); 
					const canvas = document.createElement('canvas'); 
					canvas.width = target.w; 
					canvas.height = target.h; 
					const ctx = canvas.getContext('2d'); 
					ctx.drawImage(img, 0, 0, target.w, target.h); 
					const mime = formatSel.value; 
					const useQuality = mime !== 'image/png'; 
					const dataUrl = canvas.toDataURL(mime, useQuality ? Math.min(1, Math.max(0.1, parseFloat(quality.value || '0.8'))) : undefined); 
					const baseName = (files[i].name || `image_${i+1}`).replace(/\.[^.]+$/, ''); 
					const ext = mime === 'image/jpeg' ? 'jpg' : (mime === 'image/webp' ? 'webp' : 'png'); 
					const b64 = dataUrl.split(',')[1]; 
					zip.file(`${baseName}-compressed.${ext}`, b64, { base64: true }); 
					progressEl.value = i + 1; 
				} 
				const blob = await zip.generateAsync({ type: 'blob' }); 
				if (zipBlobUrl) URL.revokeObjectURL(zipBlobUrl); 
				zipBlobUrl = URL.createObjectURL(blob); 
				downloadZipBtn.disabled = false; 
				compressBtn.disabled = false; 
				progressEl.style.display = 'none'; 
				hintEl.textContent = 'Compression complete. Download ZIP.'; 
			} catch (e) { 
				console.error(e); 
				logError('Compression failed', e && e.message); 
				progressEl.style.display = 'none'; 
				compressBtn.disabled = false; 
			} 
		});
		
		downloadZipBtn.addEventListener('click', () => { if (!zipBlobUrl) return; const a = document.createElement('a'); a.href = zipBlobUrl; a.download = 'compressed_images.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); });

		window.addEventListener('unload', () => { if (zipBlobUrl) URL.revokeObjectURL(zipBlobUrl); if (jsZipBlobUrl) URL.revokeObjectURL(jsZipBlobUrl); createdObjectUrls.forEach(u => URL.revokeObjectURL(u)); createdObjectUrls.clear(); });
		</div>
	</div>
	</script>
</body>
</html>
