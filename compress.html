<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Image Compressor</title>
	<style>
		:root {
			--bg: #ffffff;
			--text: #222;
			--muted: #666;
			--border: #e9e9e9;
			--accent: #222;
			--hover: #f8f8f8;
			--shadow: 0 2px 8px rgba(0,0,0,0.1);
			--shadow-hover: 0 4px 16px rgba(0,0,0,0.15);
			--primary: #F89344;
			--secondary: #FF642F;
		}
		body { 
			font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, Arial, sans-serif; 
			margin: 0;
			color: var(--text);
			background: var(--bg);
			line-height: 1.6;
		}
		.container { max-width: 1100px; margin: 0 auto; padding: 24px; }
		.ad-space-left { position: fixed; left: 0; top: 0; width: 160px; height: 100vh; background: #f8f8f8; border-right: 1px solid var(--border); z-index: 5; }
		.ad-space-right { position: fixed; right: 0; top: 0; width: 160px; height: 100vh; background: #f8f8f8; border-left: 1px solid var(--border); z-index: 5; }
		.main-content { margin-left: 160px; margin-right: 160px; }
		@media (max-width: 1200px) {
			.ad-space-left, .ad-space-right { display: none; }
			.main-content { margin-left: 0; margin-right: 0; }
		}
		h1 { font-size: 28px; margin: 0 0 24px; font-weight: 600; }
		
		/* Drag and Drop Zone */
		.drop-zone {
			border: 3px dashed var(--border);
			border-radius: 16px;
			padding: 60px 20px;
			text-align: center;
			background: var(--hover);
			transition: all 0.3s ease;
			cursor: pointer;
			margin-bottom: 24px;
			position: relative;
		}
		.drop-zone.dragover {
			border-color: var(--primary);
			background: rgba(248, 147, 68, 0.05);
			transform: scale(1.02);
		}
		.drop-zone .icon {
			font-size: 48px;
			margin-bottom: 16px;
			opacity: 1;
			background: rgba(10,102,255,.08);
			border: none;
			border-radius: 12px;
			width: 64px;
			height: 64px;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			color: #0A66FF;
		}
		.drop-zone .text {
			font-size: 18px;
			font-weight: 500;
			margin-bottom: 8px;
			color: var(--text);
		}
		.drop-zone .subtext {
			font-size: 14px;
			color: var(--muted);
		}
		.drop-zone input[type="file"] {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			opacity: 0;
			cursor: pointer;
			z-index: 1;
		}
		
		.controls { 
			display: grid; 
			grid-template-columns: 1fr 1fr 1fr 1fr; 
			gap: 16px; 
			margin: 24px 0; 
			align-items: end; 
		}
		label { 
			font-size: 14px; 
			color: var(--text); 
			font-weight: 500;
			margin-bottom: 8px;
			display: block;
		}
		input[type="number"], select { 
			width: 100%; 
			padding: 12px 16px; 
			border: 2px solid var(--border); 
			outline: none; 
			background: var(--bg); 
			border-radius: 8px;
			font-size: 14px;
			transition: all 0.2s ease;
		}
		input[type="number"]:focus, select:focus {
			border-color: var(--primary);
			box-shadow: 0 0 0 3px rgba(248, 147, 68, 0.1);
		}
		button { 
			appearance: none; 
			border: none; 
			background: var(--accent); 
			color: #fff; 
			padding: 14px 24px; 
			cursor: pointer; 
			border-radius: 8px;
			font-size: 14px;
			font-weight: 500;
			transition: all 0.2s ease;
		}
		button:hover:not(:disabled) {
			transform: translateY(-1px);
			box-shadow: var(--shadow);
		}
		button:disabled { 
			background: #999; 
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}
		.note { font-size: 14px; color: var(--muted); }
		
		/* Preview */
		.preview-section { margin-top: 16px; }
		.preview-row { display: flex; gap: 12px; margin-bottom: 12px; align-items: flex-start; }
		.preview-card { flex: 1; border: 1px solid var(--border); background: var(--bg); border-radius: 8px; padding: 12px; }
		.preview-title { font-size: 13px; color: var(--muted); margin: 0 0 8px; font-weight: 500; }
		.preview-image { width: 100%; max-height: 220px; object-fit: contain; background: #fff; border: 1px solid var(--border); border-radius: 6px; padding: 4px; }
		.preview-meta { margin-top: 8px; font-size: 12px; color: var(--muted); }
		.preview-placeholder { width: 100%; max-height: 220px; min-height: 160px; display: flex; align-items: center; justify-content: center; background: #fff; border: 1px solid var(--border); border-radius: 6px; color: var(--muted); font-size: 40px; }
		
		progress { 
			width: 100%; 
			height: 8px; 
			border-radius: 4px;
			background: var(--hover);
		}
		progress::-webkit-progress-bar {
			background: var(--hover);
			border-radius: 4px;
		}
		progress::-webkit-progress-value {
			background: linear-gradient(90deg, var(--primary), var(--secondary));
			border-radius: 4px;
		}
		
		#errorBox { 
			margin-top: 16px; 
			padding: 16px; 
			border: 1px solid #f1b0b7; 
			background: #fdecef; 
			color: #75000f; 
			font-size: 14px; 
			white-space: pre-wrap; 
			display: none; 
			border-radius: 8px;
		}
		
		/* Universal nav */
		.navbar { 
			position: sticky; 
			top: 0; 
			background: var(--bg); 
			z-index: 10; 
			border-bottom: 1px solid var(--border); 
			padding: 16px 0; 
			margin-bottom: 24px; 
		}
		.nav { 
			display: flex; 
			align-items: center; 
			gap: 16px; 
		}
		.nav .brand { 
			font-weight: 600; 
			font-size: 18px;
		}
		.nav a { 
			color: var(--text); 
			text-decoration: none; 
			border: 1px solid var(--border); 
			padding: 8px 16px; 
			border-radius: 6px;
			transition: all 0.2s ease;
		}
		.nav a:hover {
			background: var(--hover);
			border-color: var(--primary);
		}
		.nav .logo { display:inline-flex; align-items:center; justify-content:center; width:44px; height:44px; border:none; border-radius:10px; font-weight:700; font-size:24px; line-height:1; color: var(--text); text-decoration:none; background:transparent; }
		.nav .logo:hover{ background: var(--hover); }
		.dropdown { 
			position: relative; 
			width: 320px; 
		}
		.dropdown input { 
			width: 100%; 
			padding: 10px 12px; 
			border: 1px solid var(--border); 
			outline: none; 
			border-radius: 6px; 
		}
		.dropdown .menu { 
			position: absolute; 
			left: 0; 
			right: 0; 
			background: var(--bg); 
			border: 1px solid var(--border); 
			border-top: none; 
			max-height: 280px; 
			overflow: auto; 
			display: none; 
			border-radius: 0 0 6px 6px;
			box-shadow: var(--shadow);
		}
		.dropdown.open .menu { 
			display: block; 
		}
		.dropdown .item { 
			padding: 10px 12px; 
			cursor: pointer; 
			border-top: 1px solid var(--border); 
			transition: background 0.2s ease;
		}
		.dropdown .item:hover { 
			background: var(--hover); 
		}
		
		@media (max-width: 768px) {
			.container { padding: 16px; }
			.controls { grid-template-columns: 1fr 1fr; }
		}
	</style>
	<link rel="stylesheet" href="ui.css">
	<script src="media-picker.js"></script>
    <script defer src="ui.js"></script>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
</head>
<body>
	<div class="ad-space-left"></div>
	<div class="ad-space-right"></div>
	<div class="main-content">
		<div class="container">
		<div class="navbar">
			<div class="nav">
				<a href="index.html" class="logo" aria-label="Home">‚àû</a>
				<div class="spacer"></div>
			</div>
		</div>

		<h1>üóúÔ∏è Image Compressor</h1>
		
		<div class="drop-zone" id="dropZone">
			<div class="icon">üìÅ</div>
			<div class="text">Drop images here or click to browse</div>
			<div class="subtext">Supports PNG, JPG, GIF, SVG files</div>
			<input id="fileInput" type="file" accept="image/*,image/svg+xml" multiple style="display:none;">
		</div>
		
		<div class="controls">
			<div>
				<label for="maxW">Max width (px)</label>
				<input id="maxW" type="number" min="1" placeholder="auto">
			</div>
			<div>
				<label for="maxH">Max height (px)</label>
				<input id="maxH" type="number" min="1" placeholder="auto">
			</div>
			<div>
				<label for="quality">Quality (0.1-1)</label>
				<input id="quality" type="number" min="0.1" max="1" step="0.1" value="0.3">
			</div>
			<div>
				<label for="format">Format</label>
				<select id="format">
					<option value="" selected>Auto</option>
					<option value="image/jpeg">JPEG</option>
					<option value="image/webp">WEBP</option>
					<option value="image/png">PNG (no quality)</option>
				</select>
			</div>
		</div>
		
		<div class="row" style="gap:16px; align-items:center; margin-bottom: 24px;">
			<button id="compressBtn" disabled>üóúÔ∏è Compress</button>
			<button id="downloadZipBtn" disabled>üíæ Download ZIP</button>
			<span class="note" id="hint">Select images to compress.</span>
		</div>
		
		<div style="margin-top:16px;">
			<progress id="progress" value="0" max="1" style="display:none;"></progress>
		</div>

		<div id="previewSection" class="preview-section" style="display:none;">
			<h3 style="margin: 12px 0; font-size:16px;">Preview</h3>
			<div id="previewGrid"></div>
		</div>
		
		<div id="errorBox"></div>
	</div>

	<script>

	</script>

	<script>
		const fileInput = document.getElementById('fileInput');
		const dropZone = document.getElementById('dropZone');
		const maxW = document.getElementById('maxW');
		const maxH = document.getElementById('maxH');
		const quality = document.getElementById('quality');
		const formatSel = document.getElementById('format');
		const compressBtn = document.getElementById('compressBtn');
		const downloadZipBtn = document.getElementById('downloadZipBtn');
		const progressEl = document.getElementById('progress');
		const hintEl = document.getElementById('hint');
		const errorBox = document.getElementById('errorBox');
		const previewSection = document.getElementById('previewSection');
		const previewGrid = document.getElementById('previewGrid');

		let jsZipBlobUrl = null; let zipBlobUrl = null; const createdObjectUrls = new Set();
		let selectedFiles = [];
		let previewRows = [];

		function logError(message, detail) { const lines = []; if (message) lines.push(message); if (detail) lines.push(String(detail)); errorBox.textContent = lines.join('\n'); errorBox.style.display = lines.length ? 'block' : 'none'; }
		
		// Native picker wiring (no external APIs)
		fileInput.addEventListener('change', ()=>{ if(fileInput.files&&fileInput.files.length){ handleFiles(filterImages(Array.from(fileInput.files))); fileInput.value=''; } });
		dropZone.addEventListener('dragover', (e)=>{ e.preventDefault(); dropZone.classList.add('dragover'); });
		dropZone.addEventListener('dragleave', ()=>{ dropZone.classList.remove('dragover'); });
		dropZone.addEventListener('drop', (e)=>{ e.preventDefault(); dropZone.classList.remove('dragover'); const fs=(e.dataTransfer&&e.dataTransfer.files)?Array.from(e.dataTransfer.files):[]; if(fs.length) handleFiles(filterImages(fs)); });
		dropZone.addEventListener('click', (e)=>{ const inFileArea = e.target && (e.target.id==='fileInput' || (e.target.closest && e.target.closest('input[type="file"]'))); if(!inFileArea) fileInput.click(); });
		fileInput.addEventListener('click', (e)=>{ e.stopPropagation(); });

		function handleFiles(files) {
			selectedFiles = files;
			if (zipBlobUrl) { URL.revokeObjectURL(zipBlobUrl); zipBlobUrl = null; }
			downloadZipBtn.disabled = true;
			const images = filterImages(Array.from(files||[]));
			compressBtn.disabled = images.length === 0;
			hintEl.textContent = images.length ? `${images.length} image(s) ready.` : 'Select images to compress.';
			renderOriginalPreviews(images);
		}

		fileInput.addEventListener('change', () => { handleFiles(filterImages(Array.from(fileInput.files || []))); fileInput.value=''; });

		function filterImages(arr){ return (arr||[]).filter(f=>{ if(!f) return false; if (f.type && (f.type.startsWith('image/')||f.type==='image/svg+xml')) return true; const n=(f.name||'').toLowerCase(); return /\.(png|jpe?g|gif|svg|webp|bmp)$/i.test(n); }); }
		function formatBytes(bytes){ if(!Number.isFinite(bytes)||bytes<0) return '0 B'; const units=['B','KB','MB','GB']; let i=0; let v=bytes; while(v>=1024&&i<units.length-1){ v/=1024; i++; } return `${v.toFixed(v<10&&i>0?2:1)} ${units[i]}`; }
		function dataUrlToBlob(dataUrl){ const parts=dataUrl.split(','); const mime=(parts[0].match(/data:(.*?);base64/)||[])[1]||'application/octet-stream'; const binary=atob(parts[1]||''); const len=binary.length; const bytes=new Uint8Array(len); for(let i=0;i<len;i++){ bytes[i]=binary.charCodeAt(i); } return new Blob([bytes], { type: mime }); }
		function renderOriginalPreviews(images){ previewGrid.innerHTML=''; previewRows=[]; if(!images||images.length===0){ previewSection.style.display='none'; return; } previewSection.style.display='block'; images.forEach((file, idx)=>{ const row=document.createElement('div'); row.className='preview-row'; const beforeCard=document.createElement('div'); beforeCard.className='preview-card'; const beforeTitle=document.createElement('div'); beforeTitle.className='preview-title'; beforeTitle.textContent='Before'; const beforeImg=document.createElement('img'); beforeImg.className='preview-image'; const beforeMeta=document.createElement('div'); beforeMeta.className='preview-meta'; const url=URL.createObjectURL(file); createdObjectUrls.add(url); beforeImg.src=url; beforeMeta.textContent=`${file.name} ‚Ä¢ ${formatBytes(file.size)}`; beforeCard.appendChild(beforeTitle); beforeCard.appendChild(beforeImg); beforeCard.appendChild(beforeMeta); const afterCard=document.createElement('div'); afterCard.className='preview-card'; const afterTitle=document.createElement('div'); afterTitle.className='preview-title'; afterTitle.textContent='After'; const afterBox=document.createElement('div'); afterBox.className='preview-placeholder'; afterBox.textContent='üóúÔ∏è'; const afterImg=document.createElement('img'); afterImg.className='preview-image'; afterImg.style.display='none'; afterImg.alt='Compressed preview'; const afterMeta=document.createElement('div'); afterMeta.className='preview-meta'; afterMeta.textContent='Pending compression‚Ä¶'; afterCard.appendChild(afterTitle); afterCard.appendChild(afterBox); afterCard.appendChild(afterImg); afterCard.appendChild(afterMeta); row.appendChild(beforeCard); row.appendChild(afterCard); previewGrid.appendChild(row); previewRows[idx]={ afterImgEl: afterImg, afterMetaEl: afterMeta, afterBoxEl: afterBox }; }); }
		// Paste support: Ctrl/Cmd+V images
		window.addEventListener('paste', (e) => {
			const items = e.clipboardData && e.clipboardData.items ? Array.from(e.clipboardData.items) : [];
			const files = items.map(it => it.getAsFile && it.getAsFile()).filter(f => f && f.type && f.type.startsWith('image/'));
			if (files.length) { e.preventDefault(); handleFiles(files); }
		});
		
		function parseSvgSize(svgText) { try { const doc = new DOMParser().parseFromString(svgText, 'image/svg+xml'); const svg = doc.documentElement; let widthAttr = svg.getAttribute('width'); let heightAttr = svg.getAttribute('height'); let width = 0, height = 0; const parseLen = (v) => { if (!v) return 0; const m = String(v).trim().match(/([\d.]+)/); return m ? Math.max(0, Math.round(parseFloat(m[1]))) : 0; }; width = parseLen(widthAttr); height = parseLen(heightAttr); if ((!width || !height) && svg.hasAttribute('viewBox')) { const vb = svg.getAttribute('viewBox').trim().split(/[\s,]+/).map(Number); if (vb.length === 4 && vb[2] > 0 && vb[3] > 0) { width = width || Math.round(vb[2]); height = height || Math.round(vb[3]); } } if (!width || !height) { width = width || 512; height = height || 512; } svg.setAttribute('width', String(width)); svg.setAttribute('height', String(height)); return { width, height, serialized: new XMLSerializer().serializeToString(svg) }; } catch (e) { return { width: 512, height: 512, serialized: svgText }; } }
		function loadImageFromFile(file) { return new Promise((resolve, reject) => { if (file.type === 'image/svg+xml') { const reader = new FileReader(); reader.onerror = () => reject(new Error(`Failed to read SVG: ${file.name}`)); reader.onload = e => { const { serialized } = parseSvgSize(String(e.target.result)); const blob = new Blob([serialized], { type: 'image/svg+xml' }); const url = URL.createObjectURL(blob); createdObjectUrls.add(url); const img = new Image(); img.onload = () => resolve(img); img.onerror = () => { URL.revokeObjectURL(url); createdObjectUrls.delete(url); reject(new Error(`Failed to load SVG image: ${file.name}`)); }; img.src = url; }; reader.readAsText(file); return; } const reader = new FileReader(); reader.onerror = () => reject(new Error(`Failed to read file: ${file.name}`)); reader.onload = e => { const img = new Image(); img.onload = () => resolve(img); img.onerror = () => reject(new Error(`Failed to load image: ${file.name}`)); img.src = e.target.result; }; reader.readAsDataURL(file); }); }
		function scaleToFit(img, maxWidth, maxHeight) { const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1); return { w: Math.round(img.width * scale), h: Math.round(img.height * scale) }; }
		async function ensureJsZip() { if (window.JSZip) return; const src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; const res = await fetch(src, { cache: 'force-cache' }); if (!res.ok) throw new Error('Failed to fetch JSZip: ' + res.status); const text = await res.text(); jsZipBlobUrl = URL.createObjectURL(new Blob([text], { type: 'application/javascript' })); await new Promise((resolve, reject) => { const s = document.createElement('script'); s.src = jsZipBlobUrl; s.onload = resolve; s.onerror = () => reject(new Error('Script load error for JSZip')); document.head.appendChild(s); }); if (!window.JSZip) throw new Error('JSZip not available after loading'); }
		async function ensurePako(){ if (window.pako && typeof window.pako.deflate === 'function') return; const src='https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js'; const res=await fetch(src, { cache: 'force-cache' }); if(!res.ok) throw new Error('Failed to fetch pako: '+res.status); const text=await res.text(); const blobUrl = URL.createObjectURL(new Blob([text], { type: 'application/javascript' })); createdObjectUrls.add(blobUrl); await new Promise((resolve, reject)=>{ const s=document.createElement('script'); s.src=blobUrl; s.onload=resolve; s.onerror=()=>reject(new Error('Script load error for pako')); document.head.appendChild(s); }); if (!(window.pako && typeof window.pako.deflate === 'function')) throw new Error('pako not available after loading'); }
		async function ensureUPNG(){ if (window.UPNG) return; await ensurePako(); const src='https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.js'; const res=await fetch(src, { cache: 'force-cache' }); if(!res.ok) throw new Error('Failed to fetch UPNG: '+res.status); const text=await res.text(); const blobUrl = URL.createObjectURL(new Blob([text], { type: 'application/javascript' })); createdObjectUrls.add(blobUrl); await new Promise((resolve, reject)=>{ const s=document.createElement('script'); s.src=blobUrl; s.onload=resolve; s.onerror=()=>reject(new Error('Script load error for UPNG')); document.head.appendChild(s); }); if (!window.UPNG) throw new Error('UPNG not available after loading'); }

		compressBtn.addEventListener('click', async () => { 
			const files = (selectedFiles || []).filter(f => f && (f.type.startsWith('image/') || f.type === 'image/svg+xml'));
			if (files.length === 0) return; 
			compressBtn.disabled = true; 
			downloadZipBtn.disabled = true; 
			progressEl.style.display = 'block'; 
			progressEl.value = 0; 
			progressEl.max = files.length; 
			logError(''); 
			try { 
				await ensureJsZip(); 
				const images = await Promise.all(files.map(loadImageFromFile)); 
				const zip = new JSZip(); 
				const maxWVal = parseInt(maxW.value, 10); const maxHVal = parseInt(maxH.value, 10);
				const mw = Number.isFinite(maxWVal) && maxWVal > 0 ? maxWVal : Infinity;
				const mh = Number.isFinite(maxHVal) && maxHVal > 0 ? maxHVal : Infinity;
				for (let i = 0; i < images.length; i++) { 
					const img = images[i]; 
					const target = scaleToFit(img, mw, mh); 
					const canvas = document.createElement('canvas'); 
					canvas.width = target.w; 
					canvas.height = target.h; 
					const ctx = canvas.getContext('2d'); 
					ctx.drawImage(img, 0, 0, target.w, target.h); 
					let mime = formatSel.value; if (!mime) { const ot=(files[i].type||'').toLowerCase(); mime = (ot==='image/png'||ot==='image/svg+xml') ? 'image/png' : (ot==='image/webp' ? 'image/webp' : 'image/jpeg'); }
					const baseName = (files[i].name || `image_${i+1}`).replace(/\.[^.]+$/, ''); 
					let outBlob; let ext;
					if (mime === 'image/png') {
						await ensureUPNG();
						const imageData = ctx.getImageData(0, 0, target.w, target.h);
						const ab = UPNG.encode([imageData.data.buffer], target.w, target.h, 256);
						outBlob = new Blob([ab], { type: 'image/png' });
						ext = 'png';
					} else {
						const q = Math.min(1, Math.max(0.1, parseFloat(quality.value || '0.3')));
						const dataUrl = canvas.toDataURL(mime, q);
						outBlob = dataUrlToBlob(dataUrl);
						ext = mime === 'image/jpeg' ? 'jpg' : (mime === 'image/webp' ? 'webp' : 'png');
					}
					zip.file(`${baseName}-compressed.${ext}`, outBlob);
					// Update preview (after)
					const outUrl = URL.createObjectURL(outBlob); 
					createdObjectUrls.add(outUrl); 
					const row = previewRows[i]; 
					if (row) { 
						row.afterBoxEl.style.display = 'none'; 
						row.afterImgEl.style.display = 'block'; 
						row.afterImgEl.src = outUrl; 
						row.afterMetaEl.textContent = `${baseName}-compressed.${ext} ‚Ä¢ ${formatBytes(outBlob.size)}`; 
					}
					progressEl.value = i + 1; 
				} 
				const blob = await zip.generateAsync({ type: 'blob' }); 
				if (zipBlobUrl) URL.revokeObjectURL(zipBlobUrl); 
				zipBlobUrl = URL.createObjectURL(blob); 
				downloadZipBtn.disabled = false; 
				compressBtn.disabled = false; 
				progressEl.style.display = 'none'; 
				hintEl.textContent = 'Compression complete. Download ZIP.'; 
			} catch (e) { 
				console.error(e); 
				logError('Compression failed', e && e.message); 
				progressEl.style.display = 'none'; 
				compressBtn.disabled = false; 
			} 
		});
		
		downloadZipBtn.addEventListener('click', () => { if (!zipBlobUrl) return; const a = document.createElement('a'); a.href = zipBlobUrl; a.download = 'compressed_images.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); });

		window.addEventListener('pagehide', () => { if (zipBlobUrl) URL.revokeObjectURL(zipBlobUrl); if (jsZipBlobUrl) URL.revokeObjectURL(jsZipBlobUrl); createdObjectUrls.forEach(u => URL.revokeObjectURL(u)); createdObjectUrls.clear(); });
	</script>
		</div>
	</div>
</body>
</html>
